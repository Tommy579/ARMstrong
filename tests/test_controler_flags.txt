# Test Vector for Flags APSR (Projet PARM) - FULL BINARY
# Based on documentation 6.3.4 and circuit schematic
# Logic: New_Flag = (Flags_In & Mask) | (Old_Flag & ~Mask)

# INPUTS:
# Flags_In[4]: New flags generated by ALU (Order: NZCV)
# Update_Mask[4]: 1 to update the bit, 0 to keep old value
# Clk[1]: Clock signal (Register updates on rising edge)
# Reset[1]: Asynchronous Reset

# OUTPUTS:
# Flags_Out[4]: Stored flags state (Order: NZCV)

Flags_In[4] Update_Mask[4] Clk[1] Reset[1] Flags_Out[4]

# --- 1. RESET ---
# Initialize register to 0000
1111 1111 0 1 0000
1111 1111 1 1 0000
1111 1111 0 0 0000

# --- 2. FULL UPDATE (Mask = 1111) ---
# Scenario: CMP instruction updates all flags.
# Input: 1010 (Negative, Carry). Mask: 1111.
# Expected: Flags_Out becomes 1010.
1010 1111 0 0 0000
1010 1111 1 0 1010

# --- 3. NO UPDATE (Mask = 0000) ---
# Scenario: Instruction like MOV that might not update flags (depending on variant)
# Input: 0101 (Zero, Overflow). Mask: 0000.
# Expected: Flags_Out ignores input and keeps 1010.
0101 0000 0 0 1010
0101 0000 1 0 1010

# --- 4. PARTIAL UPDATE (Mask = 0011 -> C, V) ---
# Scenario: Instruction updating only Carry and Overflow.
# Current State: 1010 (N=1, Z=0, C=1, V=0)
# Input:         1101 (N=1, Z=1, C=0, V=1)
# Mask:          0011 (Update C and V only)
# Logic