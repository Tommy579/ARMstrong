# Test Vector for ALU 32-bits (Projet PARM) - FULL BINARY
# Format: Codop[4] A[32] B[32] Shift[5] CarryIn[1] S[32] Flags[4]
# Flags Order: N(8) Z(4) C(2) V(1)

Codop[4] A[32] B[32] Shift[5] CarryIn[1] S[32] Flags[4]

# --- 1. ARITHMETIC (ADD, SUB, MUL) ---
# ADD (ADC with Cin=0): 2 + 3 = 5
0101 00000000000000000000000000000010 00000000000000000000000000000011 00000 0 00000000000000000000000000000101 0000
# ADD Overflow: MaxPos + 1 = MinNeg (Set N and V -> 1001)
0101 01111111111111111111111111111111 00000000000000000000000000000001 00000 0 10000000000000000000000000000000 1001
# ADD Carry: -1 + 1 = 0 (Set Z and C -> 0110)
0101 11111111111111111111111111111111 00000000000000000000000000000001 00000 0 00000000000000000000000000000000 0110
# SUB (SBC with Cin=1): 5 - 3 = 2 (Set C -> 0010)
0110 00000000000000000000000000000101 00000000000000000000000000000011 00000 1 00000000000000000000000000000010 0010
# SUB Negative: 3 - 5 = -2 (Set N -> 1000). No Carry (borrow used)
0110 00000000000000000000000000000011 00000000000000000000000000000101 00000 1 11111111111111111111111111111110 1000
# MUL: 3 * 4 = 12
1101 00000000000000000000000000000011 00000000000000000000000000000100 00000 0 00000000000000000000000000001100 0000

# --- 2. LOGIC (AND, ORR, EOR, BIC, MVN) ---
# AND: Masking FFFF0000 & 00FFFF00
0000 11111111111111110000000000000000 00000000111111111111111100000000 00000 0 00000000111111110000000000000000 0000
# ORR: 1 | 2 = 3
1100 00000000000000000000000000000001 00000000000000000000000000000010 00000 0 00000000000000000000000000000011 0000
# EOR: XOR same value = 0 (Set Z -> 0100)
0001 11111111111111111111111111111111 11111111111111111111111111111111 00000 0 00000000000000000000000000000000 0100
# BIC: A & ~B (Clear last 4 bits) -> Result negative (Set N -> 1000)
1110 11111111111111111111111111111111 00000000000000000000000000001111 00000 0 11111111111111111111111111110000 1000
# MVN: NOT A (NOT 0 = -1) -> (Set N -> 1000)
1111 00000000000000000000000000000000 00000000000000000000000000000000 00000 0 11111111111111111111111111111111 1000

# --- 3. SHIFTS (LSL, LSR, ASR, ROR) ---
# LSL: 1 << 1 = 2
0010 00000000000000000000000000000000 00000000000000000000000000000001 00001 0 00000000000000000000000000000010 0000
# LSL Carry: 100...000 << 1 = 0 (Set Z=1, C=1 -> 0110)
0010 00000000000000000000000000000000 10000000000000000000000000000000 00001 0 00000000000000000000000000000000 0110
# LSR: 2 >> 1 = 1
0011 00000000000000000000000000000000 00000000000000000000000000000010 00001 0 00000000000000000000000000000001 0000
# LSR Carry: 3 >> 1 = 1 (Carry out 1) (Set C=1 -> 0010)
0011 00000000000000000000000000000000 00000000000000000000000000000011 00001 0 00000000000000000000000000000001 0010
# ASR: Keep sign (11110... >> 4 = 111111110...) (Result neg -> N=1 -> 1000)
0100 00000000000000000000000000000000 11110000000000000000000000000000 00100 0 11111111000000000000000000000000 1000
# ROR: Rotate 1 right by 1 -> 80...00 (Result neg, Carry=1 -> N=1, C=1 -> 1010)
0111 00000000000000000000000000000000 00000000000000000000000000000001 00001 0 10000000000000000000000000000000 1010

# --- 4. COMPARISON (CMP, TST) - Output S must be B ---
# CMP Equal: 5 - 5 = 0 (Set Z=1, C=1 -> 0110). Output S = B (5)
1010 00000000000000000000000000000101 00000000000000000000000000000101 00000 1 00000000000000000000000000000101 0110
# CMP Diff: 5 - 1 = 4 (Set C=1 -> 0010). Output S = B (5)
1010 00000000000000000000000000000001 00000000000000000000000000000101 00000 1 00000000000000000000000000000101 0010
# TST: 1 & 1 = 1 (Z=0). Output S = B (1)
1000 00000000000000000000000000000001 00000000000000000000000000000001 00000 0 00000000000000000000000000000001 0000
# TST Zero: 1 & 2 = 0 (Set Z=1 -> 0100). Output S = B (2)
1000 00000000000000000000000000000001 00000000000000000000000000000010 00000 0 00000000000000000000000000000010 0100